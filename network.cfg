// Everything you need to know about network settings, straight from the source (hue)
// https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking
// https://developer.valvesoftware.com/wiki/TF2_cvarlist
// CFG by: athairus

// THE FORMAT:

// "Valve documentation"
// My comments

//
// Server to client data
//

// "Number of packets per second of updates you are requesting from the server"
// Equal to the hard-coded tickrate of TF2 servers (66)
// The default is 20, but for top tier players like _you_ it should be 66 :)
// Lower to 40 if choke is significant (the server you're playing on sucks if you have to)
// Choke is the number of packets the server tries to send to you but can't
cl_updaterate 66

alias cl_updaterate_66 "cl_updaterate 66"
alias cl_updaterate_40 "cl_updaterate 40"
alias ster "cl_updaterate 33; cl_cmdrate 33"

// "Max bytes/sec the host can receive data"
// ~100KB/s, totally overkill as I usually see ~20-30KB/s max
// Nothing wrong with overkill here!
rate "100000"

//
// Client to server data
//

// "Max number of command packets sent to server per second"
// By default, the max amount the server will let you send is 66
// Let's set it to that
cl_cmdrate 66

//
// Client prediction (your guy)
//

// "Perform client side prediction."
// Predict what your inputs will do to the server's simulation, from the client side.
// Default 1 (on). You'd be insane to turn this off as your game would ignore your local keybord + mouse inputs
// and use the server's broadcasts, in other words what all other players get a few dozen ms later. 
cl_predict 1

// "Optimize for not copying data if didn't receive a network update (1), and also for not repredicting if there were no errors (2)."
// Apparently, this should never be changed, default is perfect
cl_pred_optimize 2 

// "Perform server side lag compensation of weapon firing events."
// Tell the server to compensate for the fact your inputs do not reach the server instantly (based on your ping),
// pretty much mandatory unless you like leading your shots...
cl_lagcompensation 1 

// "Smooth view/eye origin after prediction errors | Smooth client's view after prediction error over this many seconds"
// Prediction error smoothing: when your client doesn't have the correct picture of what's going on 
// with your character's position on the server simulation (as the server always has the final say), 
// smoothly move your character over cl_smoothtime seconds to its rightful place.
cl_smooth 1
cl_smoothtime 0.01667 // 16.67ms (1/60sec, set to 1/[fps of monitor])

//
// Client entity interpolation (everyone else on your screen)
//

// Buffer the snapshots received from the server by (lerp) seconds, interpolating between snapshots whenever it's time for the renderer to render.
// Default server configuration limits setting this to between 1 to 5 ticks (15ms to 75ms).
// Note that cl_interp is only clamped at the _lower_ bound by sv_client_XXX_interp_ratio
// You get two ways to set it: explicitly or as a function of the tick rate.
// The final value aka "lerp" = max( cl_interp, cl_interp_ratio / cl_updaterate (=66) ).

// NOTE: If you (practically) never lose any packets, then you'd pretty much be okay with lerp = 1 / cl_updaterate (=66) for ALL CLASSES.
// By default (server-side) this is the lowest possible value you can use.
// You can think of the interpolation buffer (lerp) length as additional time added to your ping.
// It's in your best interest to keep lerp as low as possible.

// lerp corrects packet loss
// Make sure lerp is longer than two ticks (>30ms by default, plus jitter) if you want it to compensate for a single packet being lost.
// If you're losing packets regularly, play on another server or call your ISP because something's up...
// Losing packets is on a whole other level of suckage compared to non-zero choke.

// lerp corrects jitter
// When packets come to your client later than they should, their position in the lerp buffer must be shifted backwards in time to their rightful place
// If the packet was already in use for interpolation, then some undesirable acceleration of interpolation happens
// To avoid this, for hitscan weapons, have at least 2 packets in the interp buffer at any given time. The 'newest' one can be shifted back in time to its rightful place without affecting what you're seeing on-screen
// For projectile weapons, this doesn't matter as much since projectiles are all server-side. Having 1 packet in the buffer is fine.
// Note that the flamethrower counts as a projectile here.

// "Sets the interpolation amount (bounded on low side by server interp ratio settings)."
// Value is in seconds
// Set to 0 to not have it not be a factor in final lerp calculation
// Open up net_graph 4 and observe "var". See what its absolute max ever gets on any server, then add a few ms to be safe
//      "var" represents ping jitter. Divide by 1000, and there's your value for "MAX JITTER" (in seconds)
//      I will assume your MAX JITTER = 5ms = 0.005s, which is reasonable for a good connection
//      Yours may be lower or higher if your connection is lousy
//      Expect extrapolation (bad) if your jitter exceeds what you calculated here
// Recommended values (for cl_updaterate = __):
//      hitscan: 0.030 + MAX JITTER (66)
//     (2 ticks) 0.050 + MAX JITTER (40)
//               0.060 + MAX JITTER (33)
//               0.100 + MAX JITTER (20)
//  projectiles: 0.015 + MAX JITTER (66)
//     (1 tick)  0.025 + MAX JITTER (40)
//               0.030 + MAX JITTER (33)
//               0.050 + MAX JITTER (20)
cl_interp 0.1 // Default, change per-class

// Handy aliases to put in your class configs
// Remember that you might use lower cl_updaterate values if the server chokes (see above)
alias net_hitscan_66 cl_interp 0.035
alias net_hitscan_40 cl_interp 0.055
alias net_hitscan_33 cl_interp 0.065
alias net_hitscan_20 cl_interp 0.105

alias net_projectile_66 cl_interp 0.020
alias net_projectile_40 cl_interp 0.030
alias net_projectile_33 cl_interp 0.035
alias net_projectile_20 cl_interp 0.055

// "Sets the interpolation amount (final amount is cl_interp_ratio / cl_updaterate)."
// Clamped by the server, don't use
cl_interp_ratio -1
